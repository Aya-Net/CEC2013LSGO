//
// Created by GUO XIUYI on 2025/11/5.
//

#include "uade.h"
#include "../eval_func.h"
#include <chrono>

/*
  SHADE 1.1 implemented by C++ for Special Session & Competition on Real-Parameter Single Objective Optimization at CEC-2014

  Version: 1.1   Date: 9/Jun/2014
  Written by Ryoji Tanabe (rt.ryoji.tanabe [at] gmail.com)
*/


#include <algorithm>
#include <functional>
#include <unordered_set>

Fitness UADE::run()
{
  cout << scientific << setprecision(8);
  // string fname = g_fname;
  // fout.open(fname + "_f.dat");
  // fout.precision(dbl::max_digits10);

  //cout << scientific << setprecision(8);
  initializeParameters();
  setSHADEParameters();

  vector<pair<Fitness, Individual>> pop;
  //vector<Individual> children;
  variable child[problem_size];
  //vector<Fitness> children_fitness(pop_size, 0);
  Fitness child_fitness;
  variable bsf_solution[problem_size];
  Fitness bsf_fitness;
  int nfes = 0;

  //unordered_set<DoubleRegion> popset;
  //int duplicate_count = 0;

  for (int i = 0; i < pop_size; ++i)
  {
    //initialize population
    pop.push_back({0, makeNewIndividual()});
    //children.push_back((variable *)malloc(sizeof(variable) * problem_size));

    /*DoubleRegion dr;
    dr.p = (variable *)malloc(sizeof(variable) * problem_size);
    for (int j = 0; j < problem_size; j++)
      dr.p[j] = pop.back().second[j];
    dr.size = problem_size;
    dr.nfes = nfes;
    dr.parent = 0;
    popset.emplace(dr);*/
    //evaluate the initial population
    pop[i].first = eval_sol(pop[i].second);
    // cec14_test_func(pop[i].second, &pop[i].first, problem_size, 1, function_number);

    if ((pop[i].first - optimum) < epsilon)
      pop[i].first = optimum;

    if (i==0 || (pop[i].first < bsf_fitness) )
    {
      bsf_fitness = pop[i].first;
      for (int j = 0; j < problem_size; j++)
        bsf_solution[j] = pop[i].second[j];
    }

    ++nfes;
    // fout << pop[i].first << ',' << nfes << ',' << i << ',' << -1 << ',' << pop_size << ',' << 0.5 << ',' << 0.5 << endl;
    if (nfes >= max_num_evaluations)
      break;
  }

  int num_success_params;
  variable mu_sf, mu_cr;
  int mu_ps;
  vector<variable> success_sf;
  vector<variable> success_cr;
  vector<int> success_ps;
  vector<variable> dif_fitness;

  // the contents of M_f and M_cr are all initialiezed 0.5
  vector<variable> memory_sf(memory_size, 0.5);
  vector<variable> memory_cr(memory_size, 0.5);
  vector<variable> memory_ps(memory_size, pop_size);

  variable temp_sum_sf;
  variable temp_sum_cr;
  variable temp_sum_ps;
  variable sum;
  variable weight;

  //memory index counter
  int memory_pos = 0;

  //for new parameters sampling
  int random_selected_period;
  vector<variable> pop_sf(100);
  vector<variable> pop_cr(100);
  vector<int> pop_ps(100);

  //for current-to-pbest/1
  int p_best_ind, base, r1, r2;
  int p_num = round(pop_size * p_best_rate);
  vector<tuple<Fitness, Individual, int>> pbests;
  for (int i = 0; i < p_num; ++i)
  {
    pbests.push_back({pop[i].first, (variable *)malloc(sizeof(variable) * problem_size),i});
    for (int j = 0; j < problem_size; j++)
      get<1>(pbests.back())[j] = pop[i].second[j];
  }
  make_heap(pbests.begin(), pbests.end());
  for (int i = p_num; i < pop_size; ++i)
  {
    if (pop[i].first < get<0>(pbests[0]))
    {
      pop_heap(pbests.begin(), pbests.end());
      get<0>(pbests.back()) = pop[i].first;
      for (int j = 0; j < problem_size; j++)
        get<1>(pbests.back())[j] = pop[i].second[j];
      get<2>(pbests.back()) = i;
      push_heap(pbests.begin(), pbests.end());
    }
  }/**/

  //------------------------------------------
  // for linear population size reduction
  int max_pop_size = pop_size * 20;
  int min_pop_size = 100;
#define  CHRONO
#ifdef CHRONO
  using Clock = std::chrono::high_resolution_clock;
  auto t_total_start = Clock::now();
  vector<chrono::duration<double>> t_period(10, chrono::duration<double>(0));
  auto t_loop_start = Clock::now();
#endif
  //main loop
  while (nfes < max_num_evaluations) {
#ifdef CHRONO
    auto t_parallel_start = Clock::now();
#endif
    //for (int target = 0; target < pop_size; target++)
    for (int target = 0; target < 100; target++) {
#ifdef CHRONO
      auto t_p0_start = Clock::now();
#endif
      //In each generation, CR_i and F_i used by each individual x_i are generated by first selecting an index r_i randomly from [1, H]
      random_selected_period = rand() % memory_size;
      mu_sf = memory_sf[random_selected_period];
      mu_cr = memory_cr[random_selected_period];
      mu_ps = memory_ps[random_selected_period];
      //generate CR_i and repair its value
      if (mu_cr == -1)
      {
        pop_cr[target] = 0;
      } else {
        pop_cr[target] = gauss(mu_cr, 0.1);
        if (pop_cr[target] > 1) pop_cr[target] = 1;
        else if (pop_cr[target] < 0) pop_cr[target] = 0;
      }

      //generate F_i and repair its value
      do {
        pop_sf[target] = cauchy_g(mu_sf, 0.1);
      } while (pop_sf[target] <= 0);
      if (pop_sf[target] > 1) pop_sf[target] = 1;

      //generate PS_i and repair its value
      //pop_ps[target] = pop_size; //fixed-size
      pop_ps[target] = (int)gauss(mu_ps, 10);
      if (pop_ps[target] < min_pop_size) pop_ps[target] = min_pop_size;
      else if (pop_ps[target] > (int)pop.size()) pop_ps[target] = (int)pop.size();
      else if (pop_ps[target] > max_pop_size) pop_ps[target] = max_pop_size;/**/

#ifdef CHRONO
      auto t_p1_start = Clock::now();
      t_period[0] += t_p1_start - t_p0_start;
#endif

      //p-best individual is randomly selected from the top pop_size *  p_i members
      //p_best_ind = rand() % p_num;

      int tournament = round((int)pop.size() / pop_ps[target]) * 10;
      // cout << tournament << endl;
      p_best_ind = (int)pop.size() - 1 - rand() % (int)(pop.size() * p_best_rate); //v60
      for (int t = 1; t < tournament; t++)
      {
        double tmp = (int)pop.size() - 1 - rand() % (int)(pop.size() * p_best_rate);  // ver60
        if (pop[tmp].first < pop[p_best_ind].first)
          p_best_ind = tmp;
      } /**/

#ifdef CHRONO
      auto t_p2_start = Clock::now();
      t_period[1] += t_p2_start - t_p1_start;
#endif
      int candidate[3];
      //candidate[0] = (int)pop.size() - pop_ps[target]; //uPADE6
      //candidate[0] = (int)pop.size() - max_pop_size + rand() % pop_ps[target]; //uPADE4
      //candidate[0] = (int)pop.size() - 1 - rand() % pop_ps[target]; //uPADE2
      //candidate[0] = (int)pop.size() - 1 - rand() % min_pop_size; //uPADE1
      //candidate[0] = (int)pop.size() - pop_ps[target] + rand() % min_pop_size; //av68
      //candidate[0] = max(0, (int)pop.size() - 1 - rand() % (max_pop_size - pop_ps[target]+1)); //

      /*do {
        candidate[1] = (int)pop.size() - 1 - rand() % pop_ps[target];
      } while (candidate[0] == candidate[1]);
      do {
        candidate[2] = (int)pop.size() - 1 - rand() % min((int)pop.size(), (pop_ps[target] + (int)round(pop_ps[target] * arc_rate)));
      } while ((candidate[0] == candidate[2]) || (candidate[1] == candidate[2]));/**/
      for (int i = 0; i < 3; i++)
        {
          candidate[i] = rand() % (int)pop.size();
          int t = 1;
          while (t < tournament)
          {
            double tmp = rand() % (int)pop.size();
            bool flag = false;
            do {
              flag = true;
              for (int j = 0; j < i; j++) {
                if (tmp == candidate[j]) {
                  flag = false;
                  tmp = rand() % (int)pop.size();
                  break;
                }
              }
            } while (!flag);
            t++;
            if (pop[tmp].first < pop[candidate[i]].first)
              candidate[i] = tmp;
            //if ((pop[tmp].first < pop[candidate[i]].first) && tmp < candidate[i-1]) candidate[i] = tmp; // av69
          }
        } /**/
      base = candidate[0];
      r1 = candidate[1];
      r2 = candidate[2];

#ifdef CHRONO
      auto t_p3_start = Clock::now();
      t_period[2] += t_p3_start - t_p2_start;
#endif

      operateCurrentToPBest1BinWithArchive(pop, pbests, child, base, p_best_ind, r1, r2, pop_sf[target], pop_cr[target]);

#ifdef CHRONO
      auto t_p4_start = Clock::now();
      t_period[3] += t_p4_start - t_p3_start;
#endif
      // evaluate the children's fitness values
      child_fitness = eval_sol(child);
      // cec14_test_func(child, &child_fitness, problem_size, 1, function_number);
      ++nfes;
      if (child_fitness - optimum < epsilon)
        child_fitness = optimum;
      if (child_fitness < bsf_fitness)
      {
        bsf_fitness = child_fitness;
        for (int j = 0; j < problem_size; j++)
          bsf_solution[j] = child[j];
      }

#ifdef CHRONO
      auto t_p5_start = Clock::now();
      t_period[4] += t_p5_start - t_p4_start;
#endif
      //generation alternation
      if (child_fitness < pop[base].first)
      {
        // fout << child_fitness << ',' << nfes << ',' << pop.size() << ',' << base << ',' << pop_ps[target] << ',' << pop_sf[target] << ',' << pop_cr[target] << endl;
        if (nfes >= max_num_evaluations)
          break;

        //insert child to population
        pop.push_back({child_fitness, (variable *)malloc(sizeof(variable) * problem_size)});
        for (int j = 0; j < problem_size; j++)
          pop.back().second[j] = child[j];

        /*insert child to pbests
        if (child_fitness < get<0>(pbests[0]))
        {
          if (p_num < round(pop_size * p_best_rate)) {
            pbests.push_back({child_fitness, (variable *)malloc(sizeof(variable) * problem_size), pop.size() - 1});
            ++p_num;
          } else {
            pop_heap(pbests.begin(), pbests.end());
            get<0>(pbests.back()) = child_fitness;
            get<2>(pbests.back()) = pop.size() - 1;
          }
          for (int j = 0; j < problem_size; j++)
            get<1>(pbests.back())[j] = child[j];
          push_heap(pbests.begin(), pbests.end());
        }/**/

        //successful parameters are preserved in S_F and S_CR
        success_sf.push_back(pop_sf[target]);
        success_cr.push_back(pop_cr[target]);
        success_ps.push_back(pop_ps[target]);
        dif_fitness.push_back(fabs(pop[base].first - child_fitness));
      }
#ifdef CHRONO
      auto t_p6_start = Clock::now();
      t_period[5] += t_p6_start - t_p5_start;
#endif

    }
#ifdef CHRONO
    auto t_parallel_end = Clock::now();
#endif
    if (nfes % 10000 == 0) {
      cout << "Function " << function_number << " Evaluation " << nfes <<" Population Size " << pop.size() << " Best " << bsf_fitness << " Time " << (long long)((chrono::duration<double>(t_parallel_end - t_parallel_start).count()) * 1000) << " ms" << endl;
    }
    if (bsf_fitness - optimum < epsilon) {
      bsf_fitness = optimum;
      break;
    }
    if (nfes >= max_num_evaluations)
      break;

    // if numeber of successful parameters > 0, historical memories are updated
    num_success_params = success_sf.size();
    if (num_success_params > 0) {
      memory_sf[memory_pos] = 0;
      memory_cr[memory_pos] = 0;
      memory_ps[memory_pos] = 0;
      temp_sum_sf = 0;
      temp_sum_cr = 0;
      temp_sum_ps = 0;
      sum = 0;

      for (int i = 0; i < num_success_params; i++) sum += dif_fitness[i];

      //weighted lehmer mean
      for (int i = 0; i < num_success_params; i++) {
        weight = dif_fitness[i] / sum;

        memory_sf[memory_pos] += weight * success_sf[i] * success_sf[i];
        temp_sum_sf += weight * success_sf[i];

        memory_cr[memory_pos] += weight * success_cr[i] * success_cr[i];
        temp_sum_cr += weight * success_cr[i];

        memory_ps[memory_pos] += weight * success_ps[i] * success_ps[i];
        temp_sum_ps += weight * success_ps[i];
      }

      memory_sf[memory_pos] /= temp_sum_sf;

      if (temp_sum_cr == 0 || memory_cr[memory_pos] == -1) memory_cr[memory_pos] = -1;
      else memory_cr[memory_pos] /= temp_sum_cr;

      if (temp_sum_ps > 0)
      {
        memory_ps[memory_pos] /= temp_sum_ps;
      }
      //if ((int)pop.size() < max_pop_size) memory_ps[memory_pos] = max_pop_size; //uPADE11

      //pop_size = memory_ps[memory_pos]; // for test

      //increment the counter
      memory_pos++;
      if (memory_pos >= memory_size) memory_pos = 0;

      //clear out the S_F, S_CR and delta fitness
      success_sf.clear();
      success_cr.clear();
      success_ps.clear();
      dif_fitness.clear();
    }

    // linear population reduction
    pop_size = memory_ps[memory_pos];
    //pop_size = round((((min_pop_size - max_pop_size) / (double)max_num_evaluations) * nfes) + max_pop_size); //original
    //pop_size = round((((min_pop_size - max_pop_size) / (double)max_num_evaluations) * nfes * 2) + max_pop_size); //half
    //pop_size = round((((min_pop_size - max_pop_size) / (double)max_num_evaluations) * nfes / 2.) + max_pop_size); //double
    //pop_size = round((((min_pop_size - max_pop_size) / (double)max_num_evaluations) * nfes / 4.) + max_pop_size); //quadruple

    //pop_sf.resize(pop_size);
    //pop_cr.resize(pop_size);
    //pop_ps.resize(pop_size);

    while (p_num > max(2., round(pop_size * p_best_rate))) {
      pop_heap(pbests.begin(), pbests.end());
      free(get<1>(pbests.back()));
      pbests.pop_back();
      --p_num;
    }/**/
  }
#ifdef CHRONO
  auto t_loop_end = Clock::now();
  for (int i = 0; i < 6; i++) {
    cout << "Time period " << i << ": " << (int)(t_period[i].count() * 1000) << " ms" << endl;
  }
  cout << "Total time: " << (int)(chrono::duration<double>(t_loop_end - t_loop_start).count() * 1000) << " ms" << endl;
#endif
  for (int i = 0; i < pop.size(); i++) {
    //fout << pop[i].first << ',' << nfes << endl;
    free(pop[i].second);
  }

  //for (int i = 0; i < children.size(); i++)
  //  free(children[i]);

  for (int i = 0; i < p_num; i++) {
    //fout << pbests[0].first << endl;
    pop_heap(pbests.begin(), pbests.end());
    free(get<1>(pbests.back()));
    pbests.pop_back(); // removes the largest individual
  }

  /*for (auto itr=popset.begin(); itr!=popset.end(); itr++) {
    free(itr->p);
  }*/
  fout.close();
  return bsf_fitness - optimum;
}

void UADE::operateCurrentToPBest1BinWithArchive(const vector<pair<Fitness, Individual>> &pop, const vector<tuple<Fitness, Individual, int>> &pbests, Individual child, int &target, int &p_best_individual, int &r1, int &r2, variable &scaling_factor, variable &cross_rate)
{
  int random_variable = rand() % problem_size;
  for (int i = 0; i < problem_size; i++) {
    if ((randDouble() < cross_rate) || (i == random_variable)) {
      //child[i] = pop[target].second[i] + scaling_factor * (get<1>(pbests[p_best_individual])[i] - pop[target].second[i]) + scaling_factor * (pop[r1].second[i] - pop[r2].second[i]);
      child[i] = pop[target].second[i] + scaling_factor * (pop[p_best_individual].second[i] - pop[target].second[i]) + scaling_factor * (pop[r1].second[i] - pop[r2].second[i]);
    } else  {
      child[i] = pop[target].second[i];
    }
  }
  //If the mutant vector violates bounds, the bound handling method is applied
  modifySolutionWithParentMedium(child,  pop[target].second);
}

void UADE::setSHADEParameters() {
  arc_rate = g_arc_rate;
  arc_size = (int)round(pop_size * arc_rate);
  p_best_rate = g_p_best_rate;
  memory_size = g_memory_size;
}
